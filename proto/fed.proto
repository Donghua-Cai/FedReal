syntax = "proto3";
package fed;

// 训练配置（由服务端下发，客户端也会上报用于对齐）
message TrainingConfig {
  int32 num_clients = 1;
  int32 total_rounds = 2;
  int32 local_epochs = 3;
  int32 batch_size = 4;
  float lr = 5;
  float momentum = 6;
  string partition_method = 7; // "iid" | "dirichlet"
  float dirichlet_alpha = 8;
  int32 seed = 9;
  float sample_fraction = 10;   // 每轮采样比例（0~1]
  string model_name = 11;       // 例如 "resnet18"
  int32 max_message_mb = 12;    // gRPC 最大消息大小（MB）
}

message RegisterRequest {
  string client_name = 1; // 便于日志定位
}

message RegisterReply {
  string client_id = 1;   // 由服务端分配
  int32 client_index = 2; // [0, num_clients)
  TrainingConfig config = 3;
}

message GetTaskRequest {
  string client_id = 1;
}

message TaskReply {
  int32 round = 1;            // 当前轮次
  bool participate = 2;       // 本轮是否被采样
  bytes global_model = 3;     // 当前全局模型（state_dict 序列化）
  TrainingConfig config = 4;  // 冗余携带，确保对齐
}

message UploadRequest {
  string client_id = 1;
  int32 round = 2;
  bytes local_model = 3;  // 本地训练后的完整权重（简单实现）
  int64 num_samples = 4;  // 本地训练使用的样本数（用于加权）
  // 简单指标（可选）
  double train_loss = 5;
  double train_acc = 6;
  double test_loss = 7;
  double test_acc = 8;
}

message UploadReply {
  bool accepted = 1;
  int32 round = 2; // 服务端当前轮
}

// 每个 chunk 承载一部分公共数据集的 logits（行优先 row-major）
message PublicLogitsChunk {
  string client_id  = 1;
  int32  round      = 2;

  // 当前分片 ID（从 0 开始）与是否为最后一片
  int32  chunk_id   = 3;
  bool   is_last    = 4;

  // 该分片对应的样本“全局下标”（和服务端 public set 的顺序对齐）
  // 若客户端严格按服务端 public set 顺序全量上传，也可不填 indices，
  // 但为了健壮性建议填上。
  repeated int64 indices = 10;

  // 本分片 logits，float32 按 [rows, num_classes] row-major 展平后的 bytes
  bytes  logits = 11;

  // 维度辅助信息（便于服务端快速校验）
  int32  rows          = 12;  // 本分片样本数
  int32  num_classes   = 13;  // 类别数（全分片一致）

  // 可选：总览信息（第一片或最后一片带上也行）
  int32  total_examples = 20; // 公共数据集总样本数（可选）
  int32  total_chunks   = 21; // 计划的分片数（可选）
}

message Ack { bool ok = 1; string msg = 2; }

service FederatedService {
  rpc RegisterClient(RegisterRequest) returns (RegisterReply);
  rpc GetTask(GetTaskRequest) returns (TaskReply);
  rpc UploadUpdate(UploadRequest) returns (UploadReply);
  rpc UploadPublicLogits (stream PublicLogitsChunk) returns (UploadReply);
}